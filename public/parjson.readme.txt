Parjson

ParJSON is a JSON-based template for partitioning 
rows of data into a well-defined tree of 
shaped data collections and aggregated results. 
A ParJSON filler will produce a data structure that
matches the shape of the input template.

For non-data oriented programming languages such as
Javascript, this template based data processing 
removes the need for multiple loops and if-else branches
in data preparation.

For data oriented programming languages such as R or
SQL RDBMS, ParJSON may be supported as an alternative 
window partitioning and aggregation syntax. 


---------------
Disambiguration
---------------

ParJSON: 
- the specifications

a "parjsoner": 
- any spec-compliant partitioner
- could be in any programming language 

Parjson or parjson: 
- this particular javascript parjsoner
- has tool specific usage not covered by specs 

-----
USAGE
-----

*** Instantiate ***
const tracker = Parjson(opts)

*** Add data ***
// Refresh data
tracker.reset(dataRows)

// Add individual data point
tracker.add(dataRow)

**** Access data ***
// count of all rows regardless of 
// duplication by samplename
tracker.tree.byGroup[d.groupname].total 

// count of unique samplenames
tracker.tree.byGroup[d.groupname].samples.length

--------
Glossary
--------

template -> filler -> tree @context

template[key] = 
	"term": 
		- with substitution, conversion, aggregation
	["term"]
	template
	[template]

--------------
Reserved Terms
--------------

@branch   the branch name where a result object is 
					mounted on the result tree

@parent   the parent of a result object

@root     the root result object

@dist()   a directive to "copy" a result object into
          another result tree branch. This is useful for 
          flattening result leaves into one or more 
          collections, to make it easier for an application 
          to reference the ParJSON results.

NOTE:     Parjson reserves all terms that are prefixed by "@"


-------
Symbols
-------
* Term Substitution:   
  prefix

  $   a row property value: "$name", "$children"
  
  =   a function in the fxns instantiation option

  @   substitute the whole row itself
  
  @.  an object's property or descendant's property, 
      with the second character being a user-supplied 
      separator to use for chaining nested descendants, 
      such as "@.children.children" or
      "@|children|children". 

      A separator MUST NOT BE alphanumeric.

* Term Conversion:
  suffix

  ()  call the substituted value as a function to 
      get the actual value: "=color()", "$color()"
  
  []  expect the substituted value to provide 
      an array of actual values for branching keys 
      or pushing array items: 
      "$color", =colors[]"
  
  {}  expect the substituted value to be a schema 
      to be processed and nested under the current 
      schema branch 
      
* Aggregation:

  literal 
  []    push values into an array, where the item can be: 
          ["$propname", (option) "distinct"]
          ["=locations()"]
          ["@"]
  
  prefix, in-loop
  +     increment: "+$propname", "+=normalized()", "+1" for counts
  
  -     decrement: "-$propname", "-5"
  
  <     minimum: "<$propname"
  
  >     maximum: ">$propname"


* Timing Symbols:
	Specify when to perform a substitution

	_::		perform before a data row is processed via the schema.
				Useful for applying a general cleaning function.

	:_:		perform right after a data row is processed via the 
				schema, but before all data rows have been processed. 
				For example, this may be useful for storing a running 
				parent aggregated total as a child property. 

	::_		perform after all data rows have been processed. 


------------------
Coding terminology
------------------
{
  "keyTerm": "valTerm"
}
where 
keyTerm, valTerm = aggrSymbol + subterm + convSymbol
subterm = subsSymbol + [stem|prop]

Pointer categories
schema: ":/"
tree: "#"
data: "@", "$"
functions: "="

{
	"location": "#:key"
	"average": "#=",
	"location": ":mount", //":ancestor[1]:child[0]",
	"running_total": "_running_parent$total", // runtime value
	"final_total": "_parent$total", // result value
	"average": "|average()", // pipe result to function
	
	"_before": "=clean()",
	"_index": [""],
	"_after": {
		"_indexedAt": ["test"],
		"": 
	}
	
	"#": [
		"#merge with other dataset": "#|joinData()",
	]
}

	""

	":mount": "",
	":parent": [""],
	":index": [""],
	
	"summary": {
		"#average": "=average()",
    
	},
	"#"
}

../../

#/#/:key



